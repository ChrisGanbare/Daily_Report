{
    "sql_templates": {
        "error_summary_main_query": "\n        WITH LatestDevices AS (\n            -- 步骤1: 找出每个device_code对应的最新的、有效的device_id\n            SELECT id AS device_id, device_code, customer_id\n            FROM (\n                SELECT id, device_code, customer_id, ROW_NUMBER() OVER (PARTITION BY device_code ORDER BY create_time DESC, id DESC) AS rn\n                FROM t_device\n                WHERE del_status = 1 AND device_code IS NOT NULL AND device_code != ''\n                {device_filter_condition}\n            ) AS RankedDevices\n            WHERE rn = 1\n        ),\n        StartInventory AS (\n            -- 步骤2 (已优化): 确立'绝对期初库存'。利用设备的创建日期避免不必要的历史数据查询。\n            -- 优化：使用LEFT JOIN配合子查询，提高性能（MySQL兼容）\n            SELECT\n                ld.device_id,\n                CASE\n                    -- 优化点：如果设备是在查询开始后才创建的，其期初库存必为0。\n                    WHEN d.create_time >= '{start_date_str} 00:00:00' THEN 0\n                    -- 否则，使用LEFT JOIN获取期初库存（优化：减少子查询执行次数）\n                    ELSE COALESCE(prev_order.avai_oil, 0)\n                END AS start_inventory_val\n            FROM LatestDevices ld\n            JOIN t_device d ON ld.device_id = d.id\n            LEFT JOIN (\n                SELECT o1.device_id, o1.avai_oil\n                FROM t_device_oil_order o1\n                INNER JOIN (\n                    SELECT device_id, MAX(order_time) as max_order_time\n                    FROM t_device_oil_order\n                    WHERE order_time < '{start_date_str} 00:00:00'\n                    AND status = 1\n                    GROUP BY device_id\n                ) o2 ON o1.device_id = o2.device_id AND o1.order_time = o2.max_order_time\n                WHERE o1.status = 1\n            ) AS prev_order ON prev_order.device_id = ld.device_id\n        ),\n        InventoryEvents AS (\n            -- 步骤3: 构建包含'绝对期初库存'的完整库存事件流\n            SELECT device_id, CAST('{start_date_str} 00:00:00' AS DATETIME) as order_time, 0 as oil_val, start_inventory_val as avai_oil\n            FROM StartInventory\n            UNION ALL\n            SELECT o.device_id, o.order_time, o.oil_val, o.avai_oil\n            FROM t_device_oil_order o\n            JOIN LatestDevices ld ON o.device_id = ld.device_id\n            WHERE o.order_time >= '{start_date_str} 00:00:00' AND o.order_time <= '{end_date_str} 23:59:59' AND o.status = 1\n        ),\n        PeriodAggregates AS (\n            -- 步骤4: 在完整的事件流上计算总加油量、期末库存和总订单量\n            -- 业务逻辑3：订单消耗总量（理论消耗）包含所有订单的oil_val（不区分消耗订单和入库订单）\n            -- 业务逻辑3：入库量 = 原油剩余量增量 * 桶数（不包含入库订单的oil_val）\n            SELECT\n                device_id,\n                SUM(CASE \n                    WHEN avai_oil > prev_avai_oil THEN (avai_oil - prev_avai_oil)\n                    ELSE 0\n                END) AS total_refill_inventory_increase,\n                (SELECT avai_oil FROM (SELECT avai_oil, ROW_NUMBER() OVER (PARTITION BY device_id ORDER BY order_time DESC) as rn FROM InventoryEvents i WHERE i.device_id = p.device_id) t WHERE t.rn = 1) AS end_inventory,\n                -- 业务逻辑3：理论消耗 = 所有订单的oil_val（不区分消耗订单和入库订单）\n                SUM(oil_val) AS total_order_volume\n            FROM (\n                SELECT device_id, order_time, oil_val, avai_oil, LAG(avai_oil, 1) OVER (PARTITION BY device_id ORDER BY order_time) AS prev_avai_oil\n                FROM InventoryEvents\n            ) p\n            GROUP BY device_id\n        )\n        -- 步骤5: 最终计算\n        -- 业务逻辑3：库存消耗总量 = (期初-期末) * 桶数 + 原油剩余量增量 * 桶数\n        -- 注意：total_inventory_consumption返回的是单桶值，Excel会乘以桶数得到总量\n        SELECT\n            ld.device_code,\n            c.customer_name,\n            agg.total_order_volume,\n            -- 单桶库存消耗部分（需要乘以桶数）：期初-期末+原油剩余量增量（都是单桶值）\n            (si.start_inventory_val - agg.end_inventory + agg.total_refill_inventory_increase) AS total_inventory_consumption_single_barrel\n        FROM\n            PeriodAggregates agg\n        JOIN\n            LatestDevices ld ON agg.device_id = ld.device_id\n        JOIN\n            t_customer c ON ld.customer_id = c.id\n        JOIN\n            StartInventory si ON agg.device_id = si.device_id\n        WHERE c.status = 1\n        HAVING\n            (total_order_volume IS NOT NULL)\n        ",
        "error_summary_offline_query": "\n        WITH LatestDevices AS (\n            -- 步骤1: 找出每个device_code对应的最新的、有效的device_id\n            SELECT \n                id as device_id, \n                device_code,\n                customer_id\n            FROM (\n                SELECT \n                    id, \n                    device_code, \n                    customer_id,\n                    ROW_NUMBER() OVER (PARTITION BY device_code ORDER BY create_time DESC, id DESC) as rn\n                FROM t_device\n                WHERE del_status = 1 AND device_code IS NOT NULL AND device_code != ''\n                {device_filter_condition}\n            ) AS RankedDevices\n            WHERE rn = 1\n        )\n        SELECT\n            ld.device_code,\n            f.create_time,\n            f.recovery_time,\n            f.biz_type\n        FROM\n            t_device_fault_detail f\n        JOIN\n            LatestDevices ld ON f.device_id = ld.device_id\n        WHERE\n            f.fault_type = 9999\n            AND f.create_time <= %s\n            AND (f.recovery_time IS NULL OR f.recovery_time >= %s)\n        "
    }
}
