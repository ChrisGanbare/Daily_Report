{
    "sql_templates": {
        "error_summary_main_query": "\n        WITH LatestDevices AS (\n            -- 步骤1: 找出每个device_code对应的最新的、有效的device_id\n            SELECT id AS device_id, device_code, customer_id\n            FROM (\n                SELECT id, device_code, customer_id, ROW_NUMBER() OVER (PARTITION BY device_code ORDER BY create_time DESC, id DESC) AS rn\n                FROM t_device\n                WHERE del_status = 1 AND device_code IS NOT NULL AND device_code != ''\n            ) AS RankedDevices\n            WHERE rn = 1\n        ),\n        StartInventory AS (\n            -- 步骤2 (已优化): 确立“绝对期初库存”。利用设备的创建日期避免不必要的历史数据查询。\n            SELECT\n                ld.device_id,\n                CASE\n                    -- 优化点：如果设备是在查询开始后才创建的，其期初库存必为0。\n                    WHEN d.create_time >= '{start_date_str} 00:00:00' THEN 0\n                    -- 否则，才需要去历史订单中查找期初库存。\n                    ELSE COALESCE((\n                        SELECT o.avai_oil\n                        FROM t_device_oil_order o\n                        WHERE o.device_id = ld.device_id AND o.order_time < '{start_date_str} 00:00:00'\n                        ORDER BY o.order_time DESC\n                        LIMIT 1\n                    ), 0)\n                END AS start_inventory_val\n            FROM LatestDevices ld\n            JOIN t_device d ON ld.device_id = d.id -- 必须关联设备表以获取create_time\n        ),\n        InventoryEvents AS (\n            -- 步骤3: 构建包含“绝对期初库存”的完整库存事件流\n            SELECT device_id, CAST('{start_date_str} 00:00:00' AS DATETIME) as order_time, 0 as oil_val, start_inventory_val as avai_oil\n            FROM StartInventory\n            UNION ALL\n            SELECT o.device_id, o.order_time, o.oil_val, o.avai_oil\n            FROM t_device_oil_order o\n            JOIN LatestDevices ld ON o.device_id = ld.device_id\n            WHERE o.order_time >= '{start_date_str} 00:00:00' AND o.order_time <= '{end_date_str} 23:59:59' AND o.status = 1\n        ),\n        PeriodAggregates AS (\n            -- 步骤4: 在完整的事件流上计算总加油量、期末库存和总订单量\n            -- 重要：订单消耗总量（理论消耗）只包含消耗订单的oil_val，不包含入库订单的oil_val\n            -- 修复入库量计算：当原油剩余量增加时，真实的入库量 = (原油剩余量增量) + (该订单的油加注值)\n            -- 因为原油剩余量是在扣除油加注值之后更新的，所以需要加上油加注值\n            -- 注意：原油剩余量增量是单桶值（液位计），订单油加注值是总量值（流量计）\n            -- SQL返回单桶值，Excel会乘以桶数得到总量。所以入库量的单桶等效值计算为：\n            -- total_refill（单桶值） = total_refill_inventory_increase（单桶值） + (total_refill_oil_val（总量值）/ 桶数)\n            -- 但由于SQL中不知道桶数，这里先分别计算，然后在最终计算时处理\n            SELECT\n                device_id,\n                SUM(CASE \n                    WHEN avai_oil > prev_avai_oil THEN (avai_oil - prev_avai_oil)\n                    ELSE 0\n                END) AS total_refill_inventory_increase,\n                SUM(CASE \n                    WHEN avai_oil > prev_avai_oil THEN oil_val\n                    ELSE 0\n                END) AS total_refill_oil_val,\n                (SELECT avai_oil FROM (SELECT avai_oil, ROW_NUMBER() OVER (PARTITION BY device_id ORDER BY order_time DESC) as rn FROM InventoryEvents i WHERE i.device_id = p.device_id) t WHERE t.rn = 1) AS end_inventory,\n                SUM(CASE \n                    WHEN avai_oil <= prev_avai_oil THEN oil_val\n                    ELSE 0\n                END) AS total_order_volume\n            FROM (\n                SELECT device_id, order_time, oil_val, avai_oil, LAG(avai_oil, 1) OVER (PARTITION BY device_id ORDER BY order_time) AS prev_avai_oil\n                FROM InventoryEvents\n            ) p\n            GROUP BY device_id\n        )\n        -- 步骤5: 最终计算\n        -- 注意：total_inventory_consumption返回的是单桶值，Excel会乘以桶数得到总量\n        -- 入库量计算：(原油剩余量增量（单桶值）) + (订单油加注值（总量值）)\n        -- 由于SQL返回单桶值，Excel会乘以桶数，所以需要分别返回两部分，让Excel公式正确处理\n        -- SQL返回：单桶值部分（需要乘以桶数）和总量值部分（不需要乘以桶数）\n        -- 但实际上，由于SQL返回的是单列，我们需要返回一个单桶等效值，然后在Excel中调整公式\n        -- 正确的单桶等效值 = (期初-期末) + 原油剩余量增量 + (订单油加注值 / 桶数)\n        -- 但由于SQL中不知道桶数，这里返回：单桶部分（期初-期末+原油剩余量增量）和总量部分（订单油加注值）\n        -- 然后在Excel中，通过公式：库存消耗总量 = (单桶部分 * 桶数) + 总量部分\n        SELECT\n            ld.device_code,\n            c.customer_name,\n            agg.total_order_volume,\n            -- 单桶库存消耗部分（需要乘以桶数）：期初-期末+原油剩余量增量（都是单桶值）\n            (si.start_inventory_val - agg.end_inventory + agg.total_refill_inventory_increase) AS total_inventory_consumption_single_barrel,\n            -- 总量部分（不需要乘以桶数）：订单油加注值（已经是总量值）\n            agg.total_refill_oil_val AS total_refill_oil_val\n        FROM\n            PeriodAggregates agg\n        JOIN\n            LatestDevices ld ON agg.device_id = ld.device_id\n        JOIN\n            t_customer c ON ld.customer_id = c.id\n        JOIN\n            StartInventory si ON agg.device_id = si.device_id\n        WHERE c.status = 1\n        HAVING\n            (total_order_volume IS NOT NULL) AND\n            ABS((total_inventory_consumption_single_barrel + total_refill_oil_val) - total_order_volume) > 0.01\n        ",
        "error_summary_offline_query": "\n        WITH LatestDevices AS (\n            -- 步骤1: 找出每个device_code对应的最新的、有效的device_id\n            SELECT \n                id as device_id, \n                device_code,\n                customer_id\n            FROM (\n                SELECT \n                    id, \n                    device_code, \n                    customer_id,\n                    ROW_NUMBER() OVER (PARTITION BY device_code ORDER BY create_time DESC, id DESC) as rn\n                FROM t_device\n                WHERE del_status = 1 AND device_code IS NOT NULL AND device_code != ''\n            ) AS RankedDevices\n            WHERE rn = 1\n        )\n        SELECT\n            ld.device_code,\n            f.create_time,\n            f.recovery_time,\n            f.biz_type\n        FROM\n            t_device_fault_detail f\n        JOIN\n            LatestDevices ld ON f.device_id = ld.device_id\n        WHERE\n            f.fault_type = 9999\n            AND f.create_time <= %s\n            AND (f.recovery_time IS NULL OR f.recovery_time >= %s)\n        "
    }
}